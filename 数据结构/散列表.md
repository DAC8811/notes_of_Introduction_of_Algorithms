## 散列表(哈希表)的基本概念
散列表是普通数组概念的推广。它使用一个长度与实际存储的关键字数目成比例的数组来存储。在散列表中，不是直接把关键字作为数组的下标，而是根据关键字 __计算__ 出相应的下标
## 散列表根据关键字计算计算下标的方法
### 直接寻址表
当关键字的全域U较小时，可以考虑直接寻址。使用一个数组T[0...m-1]表示动态集合。其中每个位置，称为 __槽__ ，对应一个关键字。则有:  
```
DIRECT-ADDRESS-SEARCH(T,k)
  return T[k]
DIRECT-ADDRESS-INSERT(T,x)
  T[x.key]=x
DIRECT-ADDRESS-DELETE(T,x)
  T[x.key]=NULL
```
直接寻址表的缺点较明显，如果U很大，则很难存储下一张表T，且 __实际存储__ 的关键字集合K相对U来说可能很小，造成大量浪费
### 散列表
在直接寻址方式下，具有关键字k的元素被放在槽k中。在散列方式下，该元素存放在槽h(k)中，即利用 __散列函数__ h,由关键字k计算出槽的位置  
这里存在一个问题：两个关键字可能映射到同一个槽中，称为 __冲突__   
### 散列函数

## 解决冲突的方法
### 链接法
将散列到同一槽中的所有元素都放在一个链表中，若槽中没有元素则指向NULL，则有:
```
CHAINED-HASH-INSERT(T,x)
  insert x at the head of list T[h(x.key)]
CHAINED-HASH-SEARCH(T,k)
  search for an element with key k in list T[h(k)]
CHAINED-HASH-DELETE(T,x)
  delete x from the list T[h(x.key)]
```


## 散列表(哈希表)的基本概念
散列表是普通数组概念的推广。它使用一个长度与实际存储的关键字数目成比例的数组来存储。在散列表中，不是直接把关键字作为数组的下标，而是根据关键字 __计算__ 出相应的下标
## 散列表根据关键字计算计算下标的方法
### 直接寻址表
当关键字的全域U较小时，可以考虑直接寻址。使用一个数组T[0...m-1]表示动态集合。其中每个位置，称为 __槽__ ，对应一个关键字。则有:  
```
DIRECT-ADDRESS-SEARCH(T,k)
  return T[k]
DIRECT-ADDRESS-INSERT(T,x)
  T[x.key]=x
DIRECT-ADDRESS-DELETE(T,x)
  T[x.key]=NULL
```
直接寻址表的缺点较明显，如果U很大，则很难存储下一张表T，且 __实际存储__ 的关键字集合K相对U来说可能很小，造成大量浪费
### 散列表
在直接寻址方式下，具有关键字k的元素被放在槽k中。在散列方式下，该元素存放在槽h(k)中，即利用 __散列函数__ h,由关键字k计算出槽的位置  
这里存在一个问题：两个关键字可能映射到同一个槽中，称为 __冲突__   
## 散列函数
好的散列函数应近似满足简单均匀散列假设:  
每个关键字都被等可能地散列到m个槽位中的任何一个，并与其他关键字已散列到那个槽位无关
### 除法散列法
通过取k除以m的余数，将关键字k隐射到m个槽中的某一个，即散列函数为：```h(k)=k mod m```     
例：散列表大小m=12,所给关键字k=100,则h(k)=4  
m最好取一个不太接近2的整数幂的素数，可考虑取701
### 乘法散列法
包含两个步骤:  
第一步，用关键字k乘上常数A(0<A<1),并提取kA的小数部分  
第二步，用m乘这个值，再向下取整  
即```h(k)=(int)(m(kA mod 1))```  
这里```kA mod 1```为取kA的小数部分，即```kA-(int)(kA)```  
乘法散列法的一个优点是对m的选择不是特别关键，一般选择为2的某个幂次  
### 全域散列法
在执行开始时随机选择散列函数，使之独立于要存储的关键字
## 解决冲突的方法
### 链接法
将散列到同一槽中的所有元素都放在一个链表中，若槽中没有元素则指向NULL，则有:
```
CHAINED-HASH-INSERT(T,x)
  insert x at the head of list T[h(x.key)]
CHAINED-HASH-SEARCH(T,k)
  search for an element with key k in list T[h(k)]
CHAINED-HASH-DELETE(T,x)
  delete x from the list T[h(x.key)]
```
### 开放寻址法
所有元素都存放在散列表里，即每个表项或包含动态集合的一个元素，或是NULL  
当查找某个元素时，要系统的检查所有的表项，直到找到所需的元素，或最终查明该元素不在表中  
为了使用开放寻址法插入一个元素，需要连续的检查散列表，或称为 __探查__ ,直到找到一个空槽来放置待插入的关键字为止，检查的顺序 __依赖于待插入的关键字__  
为确定探查哪些槽，将散列函数扩充，使其包含探查号（从0开始）以作为其第二个输入参数，实现如下：
```
HASH-INSERT(T,k)
  i=0
  repeat
    j=h(k,i)
    if(T[i]==NULL)
      T[j]=k
      return j
    else i=i+1
  until i==m
  error "hash table overflow"
```
查找算法如下：
```
HASH-SEARCH(T,k)
  i=0
  repeat
    j=h(k,i)
    if(T[j]==k)
      return j
    i=i+1
  until i==m
  return NULL
```



